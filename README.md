# design_patterns

本项目是根据图解设计模式而实现的。

## 类图中的关系

1. 若某个类A继承于一个Interface或Abstract类B，那么可以称A为B的实现类。**他们之间的关系可以称为实现关系。**A是B的实现。**使用空心箭头的虚线表示。**

   > 这里的B是一个抽象的概念，例如，车，树，动物，等等。我们并不知道B具体是什么，A是B的一个具体实现，可能是轿车，猫，杨树。

2. 假设B是动物，A是猫，此时有一个类C继承于A，C是布偶猫。此时A类已经是具体的动物，而C类是A类的一个更具体的划分。**他们之间的关系可以称为泛化关系。**C是A的泛化。**使用空心箭头的实线实现表示。**

3. 猫的身上有猫毛，猫猫的肉球，猫猫的胡须等等，这些组成了猫。**他们之间的关系可以称为组合关系。使用实心菱形的实线表示。**

4. 此时有一个猫舍，里面有很多很多的猫，每一只猫都是猫舍的一部分。**他们之间的关系可以称为聚合关系。使用空心菱形的实现表示。**

5. 猫舍中的某只猫，有自己的主人，称为猫主子，猫主子和这只猫之间的关系称为**关联关系。使用实线箭头表示。**

6. 猫猫要吃东西，猫猫需要依赖好吃的东西才能够活下去，此时猫猫与好吃的东西之间的关系称为**依赖关系。使用虚线箭头表示。**

在UML类图中，箭头的方向都是由子类指向父类，关于这点，**图解设计模式**中有解释：

> 在定义子类时需要通过extends关键字指定父类。因此子类一定知道父类的定义，而反过来，父类并不知道子类的定义。只有在知道对方的信息时才能指向对方，因此箭头的方向是从子类指向父类。

## 1.1 Iterator模式（迭代器模式）

在讲解此模式时，书中共实现了五个类，他们的抽象分别是迭代器接口，具体的迭代器，集合接口（由实现该接口的集合返回迭代器），具体的集合。集合中存储的类。在这种模式下的好处是将**遍历与实现分离开了**，迭代器不需要知道集合中的存储结构，集合中存储book（书中使用的具体的类）使用数组、vector、list都不会影响迭代器的遍历。在ArrayList和LinkedList中，迭代器是作为一个内部类创建的。因为在这种情况下数据结构是已知固定的，只是其中的数据类型不同，使用Iterator<>泛型来接收数据。

