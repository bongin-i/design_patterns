# design_patterns

本项目是根据图解设计模式而实现的。

## 类图中的关系

1. 若某个类A继承于一个Interface或Abstract类B，那么可以称A为B的实现类。**他们之间的关系可以称为实现关系。**A是B的实现。**使用空心箭头的虚线表示。**

   > 这里的B是一个抽象的概念，例如，车，树，动物，等等。我们并不知道B具体是什么，A是B的一个具体实现，可能是轿车，猫，杨树。

2. 假设B是动物，A是猫，此时有一个类C继承于A，C是布偶猫。此时A类已经是具体的动物，而C类是A类的一个更具体的划分。**他们之间的关系可以称为泛化关系。**C是A的泛化。**使用空心箭头的实线实现表示。**

3. 猫的身上有猫毛，猫猫的肉球，猫猫的胡须等等，这些组成了猫。**他们之间的关系可以称为组合关系。使用实心菱形的实线表示。**

4. 此时有一个猫舍，里面有很多很多的猫，每一只猫都是猫舍的一部分。**他们之间的关系可以称为聚合关系。使用空心菱形的实现表示。**

5. 猫舍中的某只猫，有自己的主人，称为猫主子，猫主子和这只猫之间的关系称为**关联关系。使用实线箭头表示。**

6. 猫猫要吃东西，猫猫需要依赖好吃的东西才能够活下去，此时猫猫与好吃的东西之间的关系称为**依赖关系。使用虚线箭头表示。**

在UML类图中，箭头的方向都是由子类指向父类，关于这点，**图解设计模式**中有解释：

> 在定义子类时需要通过extends关键字指定父类。因此子类一定知道父类的定义，而反过来，父类并不知道子类的定义。只有在知道对方的信息时才能指向对方，因此箭头的方向是从子类指向父类。

## 1.1 Iterator模式（迭代器模式）

在讲解此模式时，书中共实现了五个类，分别是**迭代器接口（Iterator），具体的迭代器（ConcreteIterator），集合接口（Aggregate）（由实现该接口的集合返回迭代器），具体的集合（ConcreteAggregate）。集合中存储的类（<?>）。这也正是一个迭代器模式中登场的角色（要理解角色的意义）**在这种模式下的好处是将**遍历与实现分离开了**，迭代器不需要知道集合中的存储结构，集合中存储book（书中使用的具体的类）使用数组、vector、list都不会影响迭代器的遍历。在ArrayList和LinkedList中，迭代器是作为一个内部类创建的。因为在这种情况下数据结构是已知固定的，只是其中的数据类型不同，使用Iterator<>泛型来接收数据。

## 2.1 Adapter模式（适配器模式）

Adapter模式分为两种：

- 类适配器模式（使用继承的适配器）
- 对象适配器模式（使用委托的适配器）--> 即将被适配的对象作为适配器的一个参数

在Adapter模式中，登场角色有**对象（Print），请求者（Main），被适配者（Banner），适配者（PrintBanner）**。

1. **对象（Target）**：对象作为一个抽象，代表需要适配的方法
2. **请求者（Client）**：请求者可以看作是一个使用者，对于使用者来说，不需要知道被适配者是如何被适配的，只需要知道能够正常工作，这也正是适配器模式的作用点。
3. **被适配（Adaptee）**：被适配者可以看作是目前已经实现的，具有既定的功能的对象，可能你无法对他进行修改。
4. **适配者（Adapter）**：适配者实现了对象中定义的方法。

在不想修改现有代码或者版本更新了的情况下可以使用适配器模式

## 3.1 Template Method模式（模板模式）

在Template Method模式中，登场角色有**抽象类（AbstractClass），具体类（ConcreteClass）**。

1. **抽象类（ AbstractClass）**：负责声明出需要实现的模板方法。
2. **具体类（ConcreteClass）**：负责实现模板方法。

## 4.1 Factory Method 模式（工厂模式）

在Factory Method模式中，登场角色有**产品（Product），创建者（Creator），具体的产品（ConcreteProduct），具体的创建者（ ConcreteCreator）。**

1. **产品（Product）**：一个抽象类，他定义了从工厂中创建出的具体的产品所具有的接口
2. **创建者（Creator）**：一个最顶级的工厂，负责生成产品。
3. **具体的创建者（ ConcreteCreator）**：用于生成具体的产品。
4. **具体的产品（ConcreteProduct）**：被具体的创建者创建出的产品。

这里所说的工厂模式是工厂方法模式。在工作中实现的工厂方法模式更多是只需要定义一个抽象的工厂接口或类，并在具体的工厂子类中实现工厂方法来创建不同类型的对象

```java
public class Factory implements IFactory {
    @Override
    public iProduct create(Integer type) {
        if(type.equals("f1")) {
            return new Product1();
        } else if(type.equals("f2")) {
            return new Product2();
        } else {
            // 可能是不存在的type，error
        }
}
```

书中的写法更加的解耦了，如果需要添加产品时不需要去修改具体的工厂类，只需要添加一个新的工厂类即可。

